\chapter{Génération d'un automate}

\paragraph{}
Nous avons vu précédemment que JDart produit un arbre des contraintes. Nous 
allons voir plus en détail dans ce chapitre comment nous pouvons faire pour 
générer un automate de notre applet à partir de notre arbre des contraintes.

\section{Analyse de la sortie}

\paragraph{}
L'arbre des contraintes de JDart suit un schéma simple : une décision conduit 
vers une autre décision ou vers un état terminal.


Une décision s'effectue sur la valeur d'une variable, elle correspond à une 
instruction conditionnel dans le code (\textbf{if/else}, \textbf{switch}) ou à 
une boucle (\textbf{while}, \textbf{for}). 

\paragraph{Condition if/else}
Une condition est l'évaluation d'une variable ou expression booléenne qui mène 
à deux états différents du programme. La sortie de JDart se compose de 
l'expression à vérifier, suivit d'une instruction si la condition est vérifié 
puis d'une autre instruction dans le cas où elle ne l'est pas :

\begin{verbatim}
Si i != 1
   instruction si vrai
   instruction si faux
\end{verbatim}

\paragraph{}
Une instruction peut être une nouvelle condition ou un état final.

\paragraph{Table switch}
Les instructions \textbf{switch} peuvent être transformé à une imbrication de 
\textbf{if/else}, où chaque \textbf{if} correspond à un \textbf{case} :

\begin{minted}{java}
 switch(i) {
 case 1:
	// code cas 1
	break;
 case 2:
	// code cas 2
	break;
 // ...
 default:
	code cas défaut
 }
\end{minted}

peut être écrit :
\begin{minted}{java}
 if(i == 1) {
	// code cas 1
 } else {
	if(i == 2) {
		// code cas 2
	} else {
		// code cas défaut
	}
 }
\end{minted}

De la même manière pour JDart, les \textbf{switch} sont une succession de 
décisions.

\paragraph{Boucle for,while}
Pour gérer le cas des boucles, JDart tente de lister les valeurs générées par 
les différentes itérations et d'imbriquer les décisions  qu'il en résulte.


Par exemple pour le code suivant :

\begin{minted}{java}
for (int j = 1; j < 4; j++) {
      if (i + j > 0) {
      	System.out.println((i + j) + " is > 0");
      } else {
      	System.out.println((i + j) + " is <= 0");
      }
}
\end{minted}
on obtient la sortie :
\begin{figure}[H]
 \centering
 \includegraphics[]{./images/jdart_loops.png}
 \caption{Sortie JDart d'une boucle for}
\end{figure}

Ici JDart énumère toutes les valeurs de $j$ de 1 à 4 et "embo\^ite" les 
condition de (if/else), nous obtenons alors une version linéaire de la boucle 
for.

Nous obtenons le même comportement avec une boucle while.

\paragraph{État final}
Un état final est une instruction dans le code qui permet à JDart d'arrêter son 
exploration dans un branche il existe de type d'état final : 
\begin{itemize}
 \item les cas d'erreurs : cela correspond le plus souvent à une exception 
levée et non attrapée.
 \item les cas valide : c'est-à-dire une instruction ou une suite 
d'instruction ne contenant aucune décision à prendre et où aucune erreur n'est 
levée. Un cas valide peut ne correspondre à aucune instruction dans le code 
source, seulement on explicite toutes les branche du code.

\begin{figure}[H]
	\centering	
	\includegraphics[scale=0.5]{images/jdart_exemple.png}
	\caption{\label{fig:jdart_sample} Exemple d'un programme exécuté avec 
JDart}
	\end{figure}
\end{itemize}

Dans cet exemple les deux états "OK" ne corresponde à aucune instruction dans 
le code seulement dans les deux aucune erreur n'est levé et la fonction prend 
fin.


\section{Construire un graphe}

\paragraph{}
Maintenant que nous comprenons mieux la structure des données que génère JDart 
nous pouvons construire l'automate qui en résulte.



\begin{comment}




\chapter{Soot}

\paragraph{}
Dans ce chapitre nous allons présenter \cite{Soot} qui est un outils permettant 
de la compilation et l'analyse du code source.

	\section{Présentation de Soot}

	\paragraph{}
	À l'origine Soot est un framework qui à pour but d'optimiser du code. 
Soot a été produit par le groupe de recherche Sable de l'université de McGill. 
Concrètement ce framework permet de :

	\begin{itemize}
		\item analyser points par points
		\item créer des graphes de séquence
		\item créer des graphes de flux de contrôle
		\item instrumenter du code
	\end{itemize}

	\paragraph{}
	Soot propose plusieurs représentations intermédiaires du code. Chaque 
représentation intermédiaire correspond à un niveau d'abstraction.

	\paragraph{Baf} est une représentation simplifiée du bytecode Java. Il 
permet de manipuler du bytecode plus simplement.
	\paragraph{Jimple} est la représentation principale de Soot. C'est une 
représentation à trois adresses, c'est-à-dire qu'une instruction peut contenir 
trois variables. Par exemple l'instruction suivante : 
	$$ a = (b + 1) * c - d$$
	Devient : 
	$$ \$i_0 = b + 1$$
	$$ \$i_1 = \$i_0 * c$$
	$$ a = \$i_1 - d$$
	où \$i0 et \$i1 sont des variables intermédiaires.


	Le jeu d'instructions est aussi réduit (15 instructions contre plus de 
200 en bytecode).
	\paragraph{Shimple} est une représentation de type \gls{SSA}, c'est une 
représentation qui interdit la réaffectation d'une variable, des versions de 
variables sont utilisées pour remplir ce critère. Par exemple le code suivant :
	$$ y = 1 $$
	$$ y = 2 $$
	$$ x = y $$
	Devient :
	$$ y_1 = 1 $$
	$$ y_2 = 2 $$
	$$ x_1 = y_2 $$ 
	Cela permet de voir que la première instruction est inutile. Shimple 
permet donc d'éliminer du code mort, de contrôler la propagation de constante...

	\paragraph{Grimp} est une représentation basé sur Jimple, elle 
n'utilise pas de variable intermédiaire ce qui la rapproche plus du langage 
Java. Elle est utilisée pour de la décomplilation ou pour de l'inspection de 
code.

\section{}

\paragraph{}
\end{comment}
