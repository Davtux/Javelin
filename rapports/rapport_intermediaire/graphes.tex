\chapter{Représentation et Analyse de graphes}
\paragraph{}

Comme nous l'avons vu auparavant, il est nécessaire de pouvoir stocker les automates générés dans la partie précédente. Pour cela, les graphes nous ont été imposés. Dans cette partie, nous vous présenterons donc les moyens que nous avons à disposition pour réaliser le stockage de graphes et nous les compareront afin d'en sélectionner le meilleur.

\section{Différents format de représentation}
  \paragraph{}
  Il existe de nombreux formats de représentation de graphes tels que le JSON, le CSV ou bien encore l'XML.
  
  Dans cette première partie, nous allons nous concentrer sur le choix du format que nous utiliserons pour stocker et réutiliser nos graphes après leur création dans l'application.
  Nous allons pour cela passer par un tableau comparatif des diverses solutions.
  

  \subsection{Liste des formats de représentation de graphes}
  La liste ci-dessous contient tous les formats de représentation de graphes à comparer : 
  \begin{itemize}
   \item CSV : est un type de fichier très répandu, il représente les informations sous forme de tableaux et est facilement lisible via la plupart des programmes. 
   \item XML : est surement le type de fichier le plus répandu, stockant les donées sous forme de balises, il est très utilisé pour toutes les applications web et orientées objets. 
   \item JSON : le petit nouveau, il est le type de fichier favoris de tous les langages orientés objets car il permet un stockage très simple de tous les types de données, des plus simples aux plus complexes. 
   \item svg : basé sur le XML, ce format est conçu pour supporter les images vectorielles.
   \item bmp : est un format d'image propriétaire lancé par Microsoft, il est assez répandu.
   \item jpg : est un autre format d'image, plus répandu que le bmp.
  \end{itemize}

  
  \subsection{Liste des éléments déterminants le choix}
  Avant de pouvoir comparer les différents types de stockage des graphes, il nous faut déterminer une grille de critères nous permettant de classer les différentes solutions en lice.
  
  La solution retenue devra donc respecter les points suivants : 
  \begin{itemize}
   \item utiliser un format libre de données.
   \item assurer la portabilité des information en étant lisible par le plus grand nombre d'applications.
   \item être simple de lecture et de traitement, tirer facilement un graphe sous forme graphique des données stockées.
   \item facilement modifiable : si on souhaite rajouter des éléments au graphe
   \item supporter le langage objet nativement, car l'automate généré sera représenté sous forme d'objet et les graphes le seront également.
  \end{itemize}
  
  \begin{table}[!h]{Tableau comparatif des formats de fichiers}
  \centering
    \begin{tabular}{p{3.5cm} p{0.50cm} p{0.5cm} p{0.50cm} p{0.5cm} p{0.50cm}}

	& \makebox[0cm][l]{\rotatebox{45}{ Format libre }} &
	\makebox[0cm][l]{\rotatebox{45}{ Inter langages }} &
	\makebox[0cm][l]{\rotatebox{45}{ Conversion en image simple}} &
	\makebox[0cm][l]{\rotatebox{45}{ Évolution simple }} &
	\makebox[0cm][l]{\rotatebox{45}{ Support objet natif }}\\
	    
    \end{tabular}
    
    \begin{tabular}{|p{3.5cm} | p{0.50cm} | p{0.5cm} | p{0.50cm} | p{0.5cm} | p{0.50cm} |}
      
      \hline  
      \textbf{CSV}	& x & x & x & x &	\\ \hline
      \textbf{XML} 	& x & x & x & x & x 	\\ \hline
      \textbf{JSON} 	& x & x & x & x & x 	\\ \hline
      \textbf{SVG} 	& x & x & x &	& x 	\\ \hline
      \textbf{BMP} 	& x & x & x &  	&  	\\ \hline
      \textbf{JPG} 	& x & x & x &  	&  	\\ 
      \hline
    \end{tabular}
  \end{table}
  
  \subsection{Bilan}
  Après comparaison, nous voyons que deux formats peuvent correspondre à notre attente : l'XML et le JSON, nous allons donc nous baser sur ces résultats pour rechercher un outil nous permettant de représenter les graphes à l'aide d'un de ces formats.

  \section{Outils de représentation existants}
  
  \paragraph{}
  Après avoir déterminé les formats de fichiers les plus appropriés, il nous faut encore trouver un outil servant à représenter et dessiner les graphes ou, si nous n'en trouvons pas un qui conviendrait, se servir d'un outil pour base afin de le modifier en implémentant les fonctions recherchées.
  
  \subsection{Fonctionnalités demandées et contraintes imposées}
  Pour répondre à tous nos besoins, la solution retenue devra implémenter les fonctionnalités suivantes : 
  \begin{itemize}
  	\item Proposer une sortie simple à comprendre pour l'utilisateur
  	\item Dessiner un graphe à partir d'un fichier source
  \end{itemize}
  
  \paragraph{}
  La solution retenue devra également répondre aux contraintes suivantes : 
  \begin{itemize}
  	\item Posséder une licence libre afin de pouvoir apporter d'éventuelles modifications au code source.
  	\item Être intégrable à notre application finale.
  	\item Être facilement maintenable dans le futur.
  \end{itemize}

  \begin{longtable}{|c|p{2cm}|p{2cm}|p{8cm}|}
    \caption{Quelques solutions possibles de représentation de graphe et leur description}\\
    \hline
    \textbf{Nom} & \textbf{Langage} & \textbf{Licence} & \textbf{Description} \\
    \hline \hline
    
    \endfirsthead
    \hline
    \textbf{Nom} & \textbf{Langage} & \textbf{Licence} & \textbf{Description} \\
    \hline \hline
    
    \endhead
	
    \textbf{Dracula \footnote{Dracula : https://www.graphdracula.net/}} & 
JavaScript & MIT & Dracula est une bibliothèque très simple à utiliser par les 
utilisateurs, des options de drag-and-drop y sont présentes. Côté développeur, 
les fonctions d'ajout de n\oe{}uds et de gestion globales des graphes ont été 
implantées ainsi que certains algorithmes commums (Dijkstra, divers 
parcours...)\\
    \hline
    \textbf{Graph\footnote{Graph :  https://github.com/clue/graph}}& PHP & MIT &  Graph est une bibliothèque créée pour représenter des graphes, l'utilisation de PHP permet de créer un affichage minimaliste et simple en réalisation en raison de l'utilisation des navigateurs webs. Cependant, il est nécessaire de mettre en place un serveur PHP, et ceci est une opération trop lourde pour être utilisée à grande échelle.\\
    \hline
    \textbf{MXGraph\footnote{MXGraph : https://www.jgraph.com/}}& JavaScript &  Apache 2.0 & MXGraph utilise un rendu SVG pour représenter les graphes, ce qui est un gros avantage, car si les graphes obtenus sont très complexes, il est toujours possible de zommer sur une zone sans perdre en lisibilité.\\
    \hline
    \textbf{JGraphx\footnote{JGraphx : https://github.com/jgraph/jgraphx}}&Java& BSD 3 & JGraphx est développé par les mêmes personnes que MXGraph, mais contrairement à ce dernier, JGraphx utilise Java Swing comme sortie. Java Swing étant en fin de vie et très difficile à adapter, cette solution est à écarter. \\
    \hline 
    \textbf{GraphStream\footnote{GraphStream : http://graphstream-project.org/}}& Java & LGPL v3.0 & GraphStream est une bibliothèque Java avec une sortie très poussée prévue pour gérer de gros graphes. Cette solution est donc accessible pour l'utilisateur, du côté développeur, le fait que la bibliothèque soit développée en Java est un gros avantage pour l'intégration à l'application. \\
    \hline
  \end{longtable}
  
  \subsection{Comparaison des bibliothèques disponibles}
  
    \begin{table}[!h]{Tableau comparatif des bibliothèques}
      
      \centering
    
    \begin{tabular}{p{3.5cm} p{0.50cm} p{0.5cm} p{0.50cm} p{0.5cm} p{0.5cm} p{0.5cm} }

	& \makebox[0cm][l]{\rotatebox{45}{ Format libre }} &
	\makebox[0cm][l]{\rotatebox{45}{ Intégration simple }} &
	\makebox[0cm][l]{\rotatebox{45}{ User-friendly}} &
	\makebox[0cm][l]{\rotatebox{45}{ Dessin à partir d'un fichier }} &
	\makebox[0cm][l]{\rotatebox{45}{ Maintenabilité }}&
	\makebox[0cm][l]{\rotatebox{45}{ Classement }}\\
	    
    \end{tabular}
    
    \begin{tabular}{|p{3.5cm} | p{0.50cm} | p{0.5cm} | p{0.50cm} | p{0.5cm} | p{0.5cm}| p{0.5cm}|}
      
      \hline  
      \textbf{Dracula} 		& x & x 			& \textcolor{green}{+}	& N/I	& \textcolor{green}{+}	& 2\\ \hline
      \textbf{Graph} 		& x & \textcolor{red}{-} 	& \textcolor{red}{-} 	& N/I 	& \textcolor{red}{-}	& 4\\ \hline
      \textbf{MXGraph} 		& x & x 			& x 			& N/I 	& \textcolor{green}{+}	& 3\\ \hline
      \textbf{JGraphx} 		& x & \textcolor{red}{-} 	& \textcolor{red}{-} 	& N/I 	& \textcolor{red}{-}	& 4\\ \hline
      \textbf{GraphStream} 	& x & \textcolor{green}{+}	& \textcolor{green}{+} 	& N/I 	& \textcolor{green}{+}	& \textbf{1}\\ 
      \hline
    \end{tabular}
    
    \begin{tabular}{c c c}
    &&\\
    x : normal & + = avantage & - = inconvénient\\
    N/I : non-implémenté & \textcolor{green}{vert} = avantage & \textcolor{red}{rouge} = inconvénient\\
    \end{tabular}

  \end{table}
  
  \subsection{Bilan}
  La solution retenue est la solution GraphStream, qui semble être celle convenant la plus aux attentes. Dans tous les cas, nous aurons à implémenter l'importation de graphes à partir de fichiers.
  
  Si au cours du développement nous nous rendons compte de l'impossibilité de nous interfacer avec GraphStream, nous aurons la possibilité de migrer vers Dracula qui est le second choix le plus intéressant.
  

  \section{Outils d'analyse existants}

  \paragraph{}
  Après avoir réussi à représenter les graphes extraits des sorties de JDart, il nous faut encore un outil capable d'analyser les graphes afin de pouvoir simplifier leur conversion en automates.

  \subsection{Description des solutions en lice}
  \paragraph{}
  Pour cette tâche, trois solutions ont été retenues, nous allons, dans cette partie réaliser un bref comparatif de chacune d'entre elles afin de déterminer laquelle permet de répondre au mieux à nos attentes.
  
  \begin{longtable}{|c|p{2cm}|p{2cm}|p{8cm}|}
    \caption{Quelques solutions d'analyse de graphe possibles et leur description}\\
    \hline
    \textbf{Nom} & \textbf{Langage} & \textbf{Licence} & \textbf{Description} \\
    \hline \hline
    
    \endfirsthead
    \hline
    \textbf{Nom} & \textbf{Langage} & \textbf{Licence} & \textbf{Description} \\
    \hline \hline
    
    \endhead
	
    \textbf{Medusa (I) \footnote{Medusa :  http://bioinformatics.oxfordjournals.org/content/21/24/4432.short}} & Java & Inconnue & Medusa est un outil de traitement des graphes destiné à décomposer et reconnaître des protéines ou des gènes. Il est composé d'une interface graphique et d'un c\oe{}ur tous deux codés en Java. Cependant, il a l'air compliqué, à priori, d'adapter cet outil à notre type d'utilisation.\\
    \hline
    \textbf{Graph-Tool \footnote{Graph-Tool : https://graph-tool.skewed.de/}}& Python/C++ & GPLv3 &  Graph-Tool est un outil très complet d'analyse et de génération de graphes, même si la partie génération n'est pas celle qui nous intéresse le plus, la partie analyse reste néanmoins assez étoffée. Elle permet, en autres, de calculer l'isomorphisme d'un graphe, l'arbre couvrant minimal, les composantes connexes. \\
    \hline
    \textbf{Gephi \footnote{Gephi :  https://gephi.org/publications/gephi-bastian-feb09.pdf}}& Java &  GPLv3 & Gephi est un logiciel Open Source implémentant une interface graphique ainsi qu'un c\oe{}ur en Java. Il permet de réaliser de nombreuses représentations de graphe ainsi que d'appliquer de nombreux calculs sur ces derniers. L'interface grahique n'étant pas notre priorité dans cette partie, il reste à noter qu'il nous sera toujours possible de nous en inspirer pour l'adapter. \\
    \hline
    \textbf{Medusa (II) \footnote{Medusa :  https://github.com/JianlongZhong/Medusa}}& Cuda/C++ &  BSD 3 & Homonyme du premier logiciel présenté, il est tout de même très différent de ce dernier : de par le langage utilisé pour le développer, CUDA à la place de Java, d'une part. Par son objectif beaucoup plus adaptatif et polyvalent, d'autre part. \\
    \hline
  \end{longtable}
  
  \paragraph{Bilan post-présentation}
  Après la présentation des différentes solutions possibles, il semble logique d'éliminer  Medusa (I) pour des raisons d'adaptabilité trop complexe à mettre en place.
  
  \subsection{Comparaison des solutions possibles}
  
  \paragraph{}
  Il nous reste donc à départager les trois solutions restantes : 
  \begin{itemize}
  	\item Graph-Tool
  	\item Gephi
  	\item Medusa
  \end{itemize}

    
    \begin{table}[H]
      
      \centering
    
    \begin{tabular}{p{3.5cm}  p{6cm}  p{6cm} }

	& \textbf{Avantages} 		& \textbf{Inconvénients}\\ 
    	
    \end{tabular}

    
    \begin{tabular}{|p{3.5cm} | p{6cm} | p{6cm} |}
      
      \hline
      \textbf{Graph-Tool} 	& Haute performance grâce à son c\oe{}ur en C++, nombreuses fonctionnalités déjà implémentées	
				& Difficulté d'intégration en raison du langage. \\ \hline
      \textbf{Gephi} 		& Certainement plus simple à intégrer à notre application en raison de son codage en Java. Nombreuses fonctionnalités déjà implémentées.
				& Contient des outils non indispensables : la GUI par exemple, ce qui rajoutera certainement une difficulté d'extraction des fonctions pouvant nous intéresser. 	\\ \hline
      \textbf{Medusa} 		& Très hautes performances sur les graphes de grande taille grâce à son parallélisme. Nombreuses fonctionnalités déjà implémentées.
				& Uniquement compatible avec du matériel Nvidia, difficulté d'intégration en raison du langage.	\\ \hline
    \end{tabular}

    \caption{Avantage et inconvénient des différents outils }
  \end{table}
  
  
  \subsection{Bilan}
  
  \paragraph{}
  Après avoir présenté les différentes solutions et établi une comparaison sommaire, il ressort que les trois solutions sont relativement équivalentes sur les fonctionnalités proposées. Seuls les langages et les manières d'arriver au résultat diffèrent.
  
  \paragraph{}
  Dans notre problématique, nous n'aurons certainement pas à gérer de trop gros graphes, en effet, bien que complexes, les applets JavaCard sont limités en taille (contrainte naturelle d'une carte à puce). Ayant également une contrainte de temps, il semble logique de préférer la solution codée en Java, nous aurons ainsi plus de simplicité à l'intégrer à notre application finale.
  
  \paragraph{}La solution retenue dans cette partie est donc \textbf{Gephi}.
  
  \section{Bilan global de la partie Graphes}
  
  \paragraph{}
  Dans ce chapitre, nous avons vu plusieurs formats de fichiers et outils permettant de répondre au problème de gestion de graphes.
  
  Nous avons donc choisi d'utiliser le format JSON pour stocker nos graphes, de nombreux outils en Java permettent de gérer simplement ce format, il y aura donc moins de travail à fournir de ce point de vue là.
  
  Concernant l'outil de représentation des graphes, GraphStream sera celui utilisé en priorité, il permettra un affichage clair et une interaction avec l'utilisateur.
  
  Pour terminer, Gephi permettra d'appliquer des traitements sur les graphes pour en tirer le maximum d'informations.
  
  
