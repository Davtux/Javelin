\chapter{Représentation des graphes}
\paragraph{}

Comme nous l'avons vu auparavent, il est nécessaire de pouvoir stocker les automates générés dans la partie précédente. Pour cela, les graphes nous ont été imposés. Dans cette partie, nous vous présenteront donc les moyens que nous avons à disposition pour réaliser le stockage de graphes et nous les compareront afin d'en selectionner le meilleur.

\section{Différents format de représentation}
  \paragraph{}
  Il existe de nombreux formats de représentation de graphes tels que le JSON, le CSV ou bien encore l'XML.
  
  Dans cette première partie, nous allons nous concentrer sur le choix du format que nous utiliserons pour stocker et réutiliser nos graphes après leur création dans l'application.
  Nous allons pour cela, passer par un tableau comparatif des diverses solutions.
  

  \paragraph{Liste des formats de représentation de graphes}
  La liste ci-dessous contient tous les formats de représentation de graphes à comparer : 
  \begin{itemize}
   \item CSV : est un type de fichier très répendu, il représente les informations sous formes de tableaux et est facilement lisible via la plupart des programmes. 
   \item XML : est surement le type de fichier le plus répendu, stockant les donées sous forme de balises, il est très utilisé pour toutes les applications webs et orientées objets. 
   \item JSON : le petit nouveau, il est le type de fichier favoris de tous les langages orientés objets car il permet un stockage très simple de tous les types de données, des plus simples aux plus complexes. 
   \item svg : basé sur le XML, ce format est conçu pour supporter les images vectorielles.
   \item bmp : est un format d'image propriétaire lancé par Microsoft, il est assez répendu.
   \item jpg : est un autre format d'image, plus répendu que le bmp.
  \end{itemize}

  
  \paragraph{Liste des éléments déterminants le choix}
  Avant de pouvoir comparer les différents types de stockage des graphes, il nous faut déterminer une grille de critères nous permettant de classer les différentes solutions en lice.
  
  La solution retenue devra donc respecter les points suivants : 
  \begin{itemize}
   \item utiliser un format libre de données.
   \item assurer la portabilité des information en étant lisible par le plus grand nombre d'applications.
   \item être simple de lecture et de traitement, tirer facilement un graphe sous forme graphique des données stockées.
   \item facilement modifiable : si on souhaite rajouter des éléments au graphe
   \item supporter le langage objet nativement, car l'automate généré sera représenté sous forme d'objet et les graphes le seront également.
  \end{itemize}
  
  \begin{table}[!h]{Tableau comparatif des formats de fichiers}
  \centering
    \begin{tabular}{p{3.5cm} p{0.50cm} p{0.5cm} p{0.50cm} p{0.5cm} p{0.50cm}}

	& \makebox[0cm][l]{\rotatebox{45}{ Format libre }} &
	\makebox[0cm][l]{\rotatebox{45}{ Inter langages }} &
	\makebox[0cm][l]{\rotatebox{45}{ Conversion en image simple}} &
	\makebox[0cm][l]{\rotatebox{45}{ Evolution simple }} &
	\makebox[0cm][l]{\rotatebox{45}{ Support objet natif }}\\
	    
    \end{tabular}
    
    \begin{tabular}{|p{3.5cm} | p{0.50cm} | p{0.5cm} | p{0.50cm} | p{0.5cm} | p{0.50cm} |}
      
      \hline  
      \textbf{CSV} & x & x & x & x &  \\ \hline
      \textbf{XML} & x & x & x & x & x \\ \hline
      \textbf{JSON} & x & x & x & x & x \\ \hline
      \textbf{SVG} & x & x & x &  & x \\ \hline
      \textbf{BMP} & x & x & x &  &  \\ \hline
      \textbf{JPG} & x & x & x &  &  \\ 
      \hline
    \end{tabular}
  \end{table}
  
  \paragraph{Choix final}
  Après comparaison, nous voyons que deux formats peuvent correspondre à notre attente : l'XML et le JSON, nous allons donc nous baser sur ces résultats pour rechercher un outil nous permettant de représenter les graphes à l'aide d'un de ces formats.

  \section{Outils de représentation existants}
  
  \paragraph{}
  Après avoir déterminé les formats de fichiers les plus appropriés, il nous faut encore trouver un outil servant à représenter et dessiner les graphes ou, si nous n'en trouvons pas un qui conviendrait, se servir d'un outil pour base afin de le modifier en implémentant les fonctions recherchées.
  
  \paragraph{Fonctionnalités demandées et contraintes imposées}
  Pour répondre à tous nos besoins, la solution retenue devra implémenter les fonctionnalités suivantes : 
  \begin{itemize}
  	\item Proposer une sortie simple à comprendre pour l'utilisateur
  	\item Dessiner un graphe à partir d'un fichier source
  \end{itemize}
  
  \paragraph{}
  La solution retenue devra également répondre aux contraintes suivantes : 
  \begin{itemize}
  	\item Posséder une licence libre afin de pouvoir apporter d'éventuelles modifications au code source.
  	\item Être intégrable à notre application finale.
  	\item Être facilement maintenable dans le futur.
  \end{itemize}

  \begin{longtable}{|c|p{2cm}|p{2cm}|p{8cm}|}
    \caption{Quelques solutions possibles et leur description}\\
    \hline
    \textbf{Nom} & \textbf{Langage} & \textbf{Licence} & \textbf{Description} \\
    \hline \hline
    
    \endfirsthead
    \hline
    \textbf{Nom} & \textbf{Langage} & \textbf{Licence} & \textbf{Description} \\
    \hline \hline
    
    \endhead
	
    \textbf{Dracula \footnote{Dracula : https://www.graphdracula.net/}} & JavaScript & MIT & Dracula est une bibliothèque très simple à utiliser par les utilisateurs, des options de drag-and-drop y sont présentes. Côté développeur, les fonctions d'ajout de noeuds et de gestion globales des graphes ont été implantées ainsi que certains algorithmes commums (Dijksta, divers parcours...)\\
    \hline
    \textbf{Graph\footnote{Graph :  https://github.com/clue/graph}}& PHP & MIT &  Graph est une bibliothèque créée pour représenter des graphes, l'utilisation de PHP permet de créer un affichage minimaliste et simple en réalisation en raison de l'utilisation des navigateurs webs. Cependant, il est nécessaire de mettre en place un serveur PHP, et ceci est une opération trop lourde pour être utilisée à grande échelle.\\
    \hline
    \textbf{MXGraph\footnote{MXGraph : https://www.jgraph.com/}}& JavaScript &  Apache 2.0 & MXGraph utilise un rendu SVG pour représenter les graphes, ce qui est un gros avantage, car si les graphes obtenus sont très complexes, il est toujours possible de zommer sur une zone sans perdre en lisibilité.\\
    \hline
    \textbf{JGraphx\footnote{JGraphx : https://github.com/jgraph/jgraphx}}&Java& BSD 3 & JGraphx est développé par les mêmes personnes que MWGraph, mais contrairement à ce dernier, JGraphx utilise Java Swing comme sortie. Java Swing étant en fin de vie et très difficile à adapter, cette solution est à écarter. \\
    \hline 
    \textbf{GraphStream\footnote{GraphStream : http://graphstream-project.org/}}& Java & LGPL v3.0 & GraphStream est une bibliothèque Java avec une sortie très poussée prévue pour gérer de gros graphes. Cette solution est donc accessible pour l'utilisateur, du côté développeur, le fait que la bibliothèque soit développée en Java est un gros avantage pour l'intégration à l'application. \\
    \hline
  \end{longtable}
  
  \paragraph{Choix de la bibliothèque}
  
    \begin{table}[!h]{Tableau comparatif des bibliothèque}
      
      \centering
    
    \begin{tabular}{p{3.5cm} p{0.50cm} p{0.5cm} p{0.50cm} p{0.5cm} p{0.5cm} p{0.5cm} }

	& \makebox[0cm][l]{\rotatebox{45}{ Format libre }} &
	\makebox[0cm][l]{\rotatebox{45}{ Intégration simple }} &
	\makebox[0cm][l]{\rotatebox{45}{ User friendly}} &
	\makebox[0cm][l]{\rotatebox{45}{ Dessin à partir d'un fichier }} &
	\makebox[0cm][l]{\rotatebox{45}{ Maintenabilité }}&
	\makebox[0cm][l]{\rotatebox{45}{ Classement }}\\
	    
    \end{tabular}
    
    \begin{tabular}{|p{3.5cm} | p{0.50cm} | p{0.5cm} | p{0.50cm} | p{0.5cm} | p{0.5cm}| p{0.5cm}|}
      
      \hline  
      \textbf{Dracula} 		& x & x & \textcolor{green}{+} & N/I & \textcolor{green}{+} & 2\\ \hline
      \textbf{Graph} 		& x & \textcolor{red}{-} & \textcolor{red}{-} & N/I & \textcolor{red}{-}& 4\\ \hline
      \textbf{MXGraph} 		& x & x & x & N/I & \textcolor{green}{+}& 3\\ \hline
      \textbf{JGraphx} 		& x & \textcolor{red}{-} & \textcolor{red}{-} & N/I & \textcolor{red}{-}& 4\\ \hline
      \textbf{GraphStream} 	& x & \textcolor{green}{+} & \textcolor{green}{+} & N/I & \textcolor{green}{+}& \textbf{1}\\ 
      \hline
    \end{tabular}
    
    \begin{tabular}{c c c}
    &&\\
    x : normal & + = avantage & - = inconvéniant\\
    N/I : non-implémenté & \textcolor{green}{vert} = avantage & \textcolor{red}{rouge} = inconvéniant\\
    \end{tabular}

  \end{table}
  
  \paragraph{Conclusion}
  La solution retenue est la solution GraphStream, qui semble être la plus convenir aux attentes. Dans tous les cas, nous aurons à implémenter l'importation de graphes à partir de fichiers.
  
  Si au cours du developpement nous nous rendons compte de l'impossibilité de nous interfacer avec GraphStream, nous aurons la possibilité de migrer vers Dracula qui est le second choix le plus intéressant.
  

  \section{Outils d'analyse existants}

  
  